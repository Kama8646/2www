const { Random } = require('random-js');
const moment = require('moment');
const crypto = require('crypto');
const config = require('../config');

// Initialize random number generator
const random = new Random();

// Store room state for each chat
const roomStates = {};

// Helper functions for TaixiuRoom
// Generate MD5 key for result verification
function generateMD5Key(roundId) {
  return crypto.createHash('md5').update(roundId.toString()).digest('hex');
}

// Get room state for a specific chat
function getRoomState(chatId) {
  if (!roomStates[chatId]) {
    // Initialize new room state
    roomStates[chatId] = {
      isActive: false,
      roundId: Date.now(),
      countdownTime: config.GAMES.TAIXIU_ROOM.COUNTDOWN_TIME,
      timeRemaining: config.GAMES.TAIXIU_ROOM.COUNTDOWN_TIME,
      bets: {
        tai: [],
        xiu: [],
        chan: [],
        le: []
      },
      totalBets: {
        tai: 0,
        xiu: 0, 
        chan: 0,
        le: 0
      },
      result: null,
      resultMD5: null,
      messageId: null,
      history: []
    };
  }
  
  return roomStates[chatId];
}

// Format the room status message
function getStatusMessage(roomState) {
  // If round is finished
  if (roomState.result) {
    const { dice, sum } = roomState.result;
    const resultTaiXiu = sum > 10 ? 'T√†i ‚ö™Ô∏è' : 'X·ªâu ‚ö´Ô∏è';
    const resultChanLe = sum % 2 === 0 ? 'Ch·∫µn üî¥' : 'L·∫ª üîµ';
    
    return `üé≤ PH√íNG T√ÄI X·ªàU - K·∫æT QU·∫¢ üé≤
    
‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì
‚îÉ  ${dice[0]} | ${dice[1]} | ${dice[2]}  ‚îÉ = ${sum}
‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ

${resultTaiXiu} | ${resultChanLe}

üë• TH√îNG TIN PH√íNG:
‚î£‚û§ T·ªïng c∆∞·ª£c T√†i: ${roomState.totalBets.tai.toLocaleString()} VNƒê (${roomState.bets.tai.length} ng∆∞·ªùi)
‚î£‚û§ T·ªïng c∆∞·ª£c X·ªâu: ${roomState.totalBets.xiu.toLocaleString()} VNƒê (${roomState.bets.xiu.length} ng∆∞·ªùi)
‚î£‚û§ T·ªïng c∆∞·ª£c Ch·∫µn: ${roomState.totalBets.chan.toLocaleString()} VNƒê (${roomState.bets.chan.length} ng∆∞·ªùi)
‚î£‚û§ T·ªïng c∆∞·ª£c L·∫ª: ${roomState.totalBets.le.toLocaleString()} VNƒê (${roomState.bets.le.length} ng∆∞·ªùi)

üîç M√£ x√°c th·ª±c MD5: ${roomState.resultMD5}
‚è∞ V√≤ng m·ªõi b·∫Øt ƒë·∫ßu sau 10 gi√¢y...`;
  }
  
  // If round is active and countdown is running
  return `üé≤ PH√íNG T√ÄI X·ªàU üé≤
  
‚è∞ Th·ªùi gian c√≤n l·∫°i: ${roomState.timeRemaining}s

üë• TH√îNG TIN PH√íNG:
‚î£‚û§ T·ªïng c∆∞·ª£c T√†i: ${roomState.totalBets.tai.toLocaleString()} VNƒê (${roomState.bets.tai.length} ng∆∞·ªùi)
‚î£‚û§ T·ªïng c∆∞·ª£c X·ªâu: ${roomState.totalBets.xiu.toLocaleString()} VNƒê (${roomState.bets.xiu.length} ng∆∞·ªùi)
‚î£‚û§ T·ªïng c∆∞·ª£c Ch·∫µn: ${roomState.totalBets.chan.toLocaleString()} VNƒê (${roomState.bets.chan.length} ng∆∞·ªùi)
‚î£‚û§ T·ªïng c∆∞·ª£c L·∫ª: ${roomState.totalBets.le.toLocaleString()} VNƒê (${roomState.bets.le.length} ng∆∞·ªùi)

üìã LU·∫¨T CH∆†I:
‚î£‚û§ T√†i: T·ªïng 3 x√∫c x·∫Øc > 10
‚î£‚û§ X·ªâu: T·ªïng 3 x√∫c x·∫Øc ‚â§ 10
‚î£‚û§ Ch·∫µn: T·ªïng chia h·∫øt cho 2
‚î£‚û§ L·∫ª: T·ªïng kh√¥ng chia h·∫øt cho 2

üí∞ L·ªÜNH ƒê·∫∂T C∆Ø·ª¢C:
/tx tai [s·ªë ti·ªÅn] - ƒê·∫∑t c∆∞·ª£c T√†i
/tx xiu [s·ªë ti·ªÅn] - ƒê·∫∑t c∆∞·ª£c X·ªâu
/tx chan [s·ªë ti·ªÅn] - ƒê·∫∑t c∆∞·ª£c Ch·∫µn
/tx le [s·ªë ti·ªÅn] - ƒê·∫∑t c∆∞·ª£c L·∫ª

üìä L·ªäCH S·ª¨ (5 PHI√äN G·∫¶N NH·∫§T):
${roomState.history.slice(0, 5).map((h, i) => {
  const taiXiu = h.sum > 10 ? 'T√†i' : 'X·ªâu';
  const chanLe = h.sum % 2 === 0 ? 'Ch·∫µn' : 'L·∫ª';
  return `#${i+1}: ${h.dice.join(' | ')} = ${h.sum} (${taiXiu} | ${chanLe})`;
}).join('\n')}

üîç M√£ x√°c th·ª±c MD5: ${roomState.resultMD5}`;
}

// Start a new round
async function startNewRound(bot, chatId) {
  const roomState = getRoomState(chatId);
  
  // Generate new round ID
  roomState.roundId = Date.now();
  
  // Reset room state
  roomState.isActive = true;
  roomState.timeRemaining = roomState.countdownTime;
  roomState.bets = { tai: [], xiu: [], chan: [], le: [] };
  roomState.totalBets = { tai: 0, xiu: 0, chan: 0, le: 0 };
  roomState.result = null;
  
  // Generate MD5 hash for result verification
  // We pre-determine the result but encrypt it with MD5
  // to prove fair play when revealed later
  const dice = [
    random.integer(1, 6),
    random.integer(1, 6),
    random.integer(1, 6)
  ];
  const sum = dice.reduce((a, b) => a + b, 0);
  
  // Store encrypted result
  roomState.resultMD5 = generateMD5Key(`${roomState.roundId}-${dice.join('')}-${sum}`);
  
  // Send initial status message
  const msg = await bot.sendMessage(
    chatId,
    getStatusMessage(roomState),
    { parse_mode: 'Markdown' }
  );
  
  // Store message ID for later updates
  roomState.messageId = msg.message_id;
  
  // Start countdown
  startCountdown(bot, chatId);
  
  return roomState;
}

// Update countdown timer
function startCountdown(bot, chatId) {
  const roomState = getRoomState(chatId);
  
  const timer = setInterval(() => {
    roomState.timeRemaining--;
    
    // Th√¥ng b√°o t·∫°i th·ªùi ƒëi·ªÉm quan tr·ªçng
    if (roomState.timeRemaining === 60 || roomState.timeRemaining === 30 || roomState.timeRemaining === 10) {
      bot.sendMessage(chatId, `‚è≥ C√íN ${roomState.timeRemaining} GI√ÇY C∆Ø·ª¢C\n\nID Phi√™n: ${roomState.roundId.toString().slice(-5)}\nK·∫øt th√∫c sau: ${roomState.timeRemaining}s`);
    }
    
    // Update the message every 5 seconds or for the last 10 seconds
    if (roomState.timeRemaining % 5 === 0 || roomState.timeRemaining <= 10) {
      bot.editMessageText(
        getStatusMessage(roomState),
        {
          chat_id: chatId,
          message_id: roomState.messageId,
          parse_mode: 'Markdown'
        }
      ).catch(err => console.error('Error updating countdown:', err));
    }
    
    // When countdown reaches 0
    if (roomState.timeRemaining <= 0) {
      clearInterval(timer);
      // G·ª≠i th√¥ng b√°o kho√° ƒë·∫∑t c∆∞·ª£c
      bot.sendMessage(chatId, `üîí ƒê√É KHO√Å C·ª¨A C∆Ø·ª¢C\n\nID Phi√™n: ${roomState.roundId.toString().slice(-5)}\nƒêang tung x√∫c x·∫Øc...`);
      rollDiceAndEndRound(bot, chatId);
    }
  }, 1000);
}

// Roll the dice and end the current round
async function rollDiceAndEndRound(bot, chatId) {
  const roomState = getRoomState(chatId);
  const db = require('../database');
  
  // Stop accepting new bets
  roomState.isActive = false;
  
  // Send dice rolling animation message
  await bot.sendMessage(chatId, "üé≤ ƒêANG QUAY X√öC X·∫ÆC...");
  
  // S·ª≠ d·ª•ng emoji üé≤ c·ªßa Telegram ƒë·ªÉ tung x√∫c x·∫Øc th·∫≠t
  const dice1 = await bot.sendDice(chatId, { emoji: 'üé≤' });
  const dice2 = await bot.sendDice(chatId, { emoji: 'üé≤' });
  const dice3 = await bot.sendDice(chatId, { emoji: 'üé≤' });
  
  // Get the actual dice values from Telegram's response
  const diceValues = [
    dice1.dice.value,
    dice2.dice.value, 
    dice3.dice.value
  ];
  
  // Calculate sum
  const sum = diceValues.reduce((a, b) => a + b, 0);
  
  // Store the results
  roomState.result = {
    dice: diceValues,
    sum: sum
  };
  
  // Add to history
  roomState.history.unshift({
    dice: diceValues,
    sum: sum,
    timestamp: moment().format('HH:mm:ss')
  });
  
  // Keep only the most recent 20 results
  if (roomState.history.length > 20) {
    roomState.history = roomState.history.slice(0, 20);
  }
  
  // Update the message with results
  await bot.editMessageText(
    getStatusMessage(roomState),
    {
      chat_id: chatId,
      message_id: roomState.messageId,
      parse_mode: 'Markdown'
    }
  );
  
  // Ch·ªù m·ªôt ch√∫t ƒë·ªÉ ng∆∞·ªùi d√πng c√≥ th·ªÉ xem r√µ k·∫øt qu·∫£ x√∫c x·∫Øc
  await new Promise(resolve => setTimeout(resolve, 2000));
  
  // X√°c ƒë·ªãnh k·∫øt qu·∫£ t√†i x·ªâu d·ª±a tr√™n gi√° tr·ªã x√∫c x·∫Øc
  // T√†i: t·ªïng > 10, X·ªâu: t·ªïng <= 10
  const isTai = sum > 10;
  const isXiu = sum <= 10;
  // Ch·∫µn: chia h·∫øt cho 2, L·∫ª: kh√¥ng chia h·∫øt cho 2
  const isChan = sum % 2 === 0;
  
  const kqTaiXiu = isTai ? "T√ÄI" : "X·ªàU";
  const kqChanLe = isChan ? "CH·∫¥N" : "L·∫∫";
  
  // G·ª≠i th√¥ng b√°o k·∫øt qu·∫£ t·ªïng h·ª£p v·ªõi th√¥ng tin r√µ r√†ng
  await bot.sendMessage(chatId, 
    `üé≤ K·∫æT QU·∫¢ PHI√äN #${roomState.roundId.toString().slice(-5)}:\n` +
    `‚î£‚û§ X√∫c x·∫Øc: ${diceValues.join(' + ')} = ${sum}\n` +
    `‚î£‚û§ K·∫øt qu·∫£: ${kqTaiXiu} - ${kqChanLe}\n` +
    `‚î£‚û§ T√†i (>10) | X·ªâu (‚â§10)\n` +
    `‚îó‚û§ ${sum > 10 ? '‚úÖ T√ÄI th·∫Øng' : '‚úÖ X·ªàU th·∫Øng'}`
  );
  
  // Process T√†i/X·ªâu bets
  roomState.bets.tai.forEach(bet => {
    const user = db.users.get(bet.userId);
    if (user) {
      if (isTai) {
        // User won
        const winAmount = Math.floor(bet.amount * config.GAMES.TAIXIU_ROOM.MULTIPLIER_TAIXIU);
        db.users.updateBalance(bet.userId, winAmount);
        
        // Add transaction record
        db.transactions.add(
          bet.userId,
          'win',
          winAmount,
          `Th·∫Øng T√†i X·ªâu Room: T√†i ${diceValues.join(' | ')} = ${sum}`
        );
        
        // Notify user
        bot.sendMessage(
          bet.userId,
          `‚ú® K·ª≥ ${roomState.roundId.toString().slice(-5)}: Th·∫Øng Room ${winAmount.toLocaleString()}\n\nüé≤ K·∫øt qu·∫£: ${diceValues.join(' | ')} = ${sum} (T√†i)`
        ).catch(() => {});
      } else {
        // User lost - add 5% to pot
        const potContribution = Math.floor(bet.amount * config.GAMES.TAIXIU_ROOM.POT_CONTRIBUTION);
        db.pots.update('taixiu', potContribution);
        
        // Add transaction record
        db.transactions.add(
          bet.userId,
          'bet',
          -bet.amount,
          `Thua T√†i X·ªâu Room: T√†i ${diceValues.join(' | ')} = ${sum}`
        );
        
        // Notify user
        bot.sendMessage(
          bet.userId,
          `‚ùå K·ª≥ ${roomState.roundId.toString().slice(-5)}: Thua Room ${bet.amount.toLocaleString()}\n\nüé≤ K·∫øt qu·∫£: ${diceValues.join(' | ')} = ${sum} (X·ªâu)`
        ).catch(() => {});
      }
    }
  });
  
  roomState.bets.xiu.forEach(bet => {
    const user = db.users.get(bet.userId);
    if (user) {
      if (!isTai) {
        // User won
        const winAmount = Math.floor(bet.amount * config.GAMES.TAIXIU_ROOM.MULTIPLIER_TAIXIU);
        db.users.updateBalance(bet.userId, winAmount);
        
        // Add transaction record
        db.transactions.add(
          bet.userId,
          'win',
          winAmount,
          `Th·∫Øng T√†i X·ªâu Room: X·ªâu ${diceValues.join(' | ')} = ${sum}`
        );
        
        // Notify user
        bot.sendMessage(
          bet.userId,
          `‚ú® K·ª≥ ${roomState.roundId.toString().slice(-5)}: Th·∫Øng Room ${winAmount.toLocaleString()}\n\nüé≤ K·∫øt qu·∫£: ${diceValues.join(' | ')} = ${sum} (X·ªâu)`
        ).catch(() => {});
      } else {
        // User lost - add 5% to pot
        const potContribution = Math.floor(bet.amount * config.GAMES.TAIXIU_ROOM.POT_CONTRIBUTION);
        db.pots.update('taixiu', potContribution);
        
        // Add transaction record
        db.transactions.add(
          bet.userId,
          'bet',
          -bet.amount,
          `Thua T√†i X·ªâu Room: X·ªâu ${diceValues.join(' | ')} = ${sum}`
        );
        
        // Notify user
        bot.sendMessage(
          bet.userId,
          `‚ùå K·ª≥ ${roomState.roundId.toString().slice(-5)}: Thua Room ${bet.amount.toLocaleString()}\n\nüé≤ K·∫øt qu·∫£: ${diceValues.join(' | ')} = ${sum} (T√†i)`
        ).catch(() => {});
      }
    }
  });
  
  // Process Ch·∫µn/L·∫ª bets
  roomState.bets.chan.forEach(bet => {
    const user = db.users.get(bet.userId);
    if (user) {
      if (isChan) {
        // User won
        const winAmount = Math.floor(bet.amount * config.GAMES.TAIXIU_ROOM.MULTIPLIER_CHANLE);
        db.users.updateBalance(bet.userId, winAmount);
        
        // Add transaction record
        db.transactions.add(
          bet.userId,
          'win',
          winAmount,
          `Th·∫Øng T√†i X·ªâu Room: Ch·∫µn ${diceValues.join(' | ')} = ${sum}`
        );
        
        // Notify user
        bot.sendMessage(
          bet.userId,
          `‚ú® K·ª≥ ${roomState.roundId.toString().slice(-5)}: Th·∫Øng Room ${winAmount.toLocaleString()}\n\nüé≤ K·∫øt qu·∫£: ${diceValues.join(' | ')} = ${sum} (Ch·∫µn)`
        ).catch(() => {});
      } else {
        // User lost - add 5% to pot
        const potContribution = Math.floor(bet.amount * config.GAMES.TAIXIU_ROOM.POT_CONTRIBUTION);
        db.pots.update('taixiu', potContribution);
        
        // Add transaction record
        db.transactions.add(
          bet.userId,
          'bet',
          -bet.amount,
          `Thua T√†i X·ªâu Room: Ch·∫µn ${diceValues.join(' | ')} = ${sum}`
        );
        
        // Notify user
        bot.sendMessage(
          bet.userId,
          `‚ùå K·ª≥ ${roomState.roundId.toString().slice(-5)}: Thua Room ${bet.amount.toLocaleString()}\n\nüé≤ K·∫øt qu·∫£: ${diceValues.join(' | ')} = ${sum} (L·∫ª)`
        ).catch(() => {});
      }
    }
  });
  
  roomState.bets.le.forEach(bet => {
    const user = db.users.get(bet.userId);
    if (user) {
      if (!isChan) {
        // User won
        const winAmount = Math.floor(bet.amount * config.GAMES.TAIXIU_ROOM.MULTIPLIER_CHANLE);
        db.users.updateBalance(bet.userId, winAmount);
        
        // Add transaction record
        db.transactions.add(
          bet.userId,
          'win',
          winAmount,
          `Th·∫Øng T√†i X·ªâu Room: L·∫ª ${diceValues.join(' | ')} = ${sum}`
        );
        
        // Notify user
        bot.sendMessage(
          bet.userId,
          `‚ú® K·ª≥ ${roomState.roundId.toString().slice(-5)}: Th·∫Øng Room ${winAmount.toLocaleString()}\n\nüé≤ K·∫øt qu·∫£: ${diceValues.join(' | ')} = ${sum} (L·∫ª)`
        ).catch(() => {});
      } else {
        // User lost - add 5% to pot
        const potContribution = Math.floor(bet.amount * config.GAMES.TAIXIU_ROOM.POT_CONTRIBUTION);
        db.pots.update('taixiu', potContribution);
        
        // Add transaction record
        db.transactions.add(
          bet.userId,
          'bet',
          -bet.amount,
          `Thua T√†i X·ªâu Room: L·∫ª ${diceValues.join(' | ')} = ${sum}`
        );
        
        // Notify user
        bot.sendMessage(
          bet.userId,
          `‚ùå K·ª≥ ${roomState.roundId.toString().slice(-5)}: Thua Room ${bet.amount.toLocaleString()}\n\nüé≤ K·∫øt qu·∫£: ${diceValues.join(' | ')} = ${sum} (Ch·∫µn)`
        ).catch(() => {});
      }
    }
  });
  
  // Hi·ªÉn th·ªã n√∫t ƒë·ªÉ b·∫Øt ƒë·∫ßu phi√™n m·ªõi thay v√¨ t·ª± ƒë·ªông b·∫Øt ƒë·∫ßu
  setTimeout(() => {
    bot.sendMessage(chatId, `üé≤ PHI√äN #${roomState.roundId.toString().slice(-5)} ƒê√É K·∫æT TH√öC\n\nB·∫°n c√≥ mu·ªën b·∫Øt ƒë·∫ßu phi√™n ƒë·∫∑t c∆∞·ª£c m·ªõi kh√¥ng?`, {
      reply_markup: {
        inline_keyboard: [
          [{ text: '‚ñ∂Ô∏è B·∫Øt ƒë·∫ßu phi√™n m·ªõi', callback_data: 'start_taixiu_room' }]
        ]
      }
    });
  }, 5000);
}

// Place a bet for a user
async function placeBet(bot, msg, userId, betType, betAmount) {
  const chatId = msg.chat.id;
  const roomState = getRoomState(chatId);
  const db = require('../database');
  
  // Check if room is active and accepting bets
  if (!roomState.isActive) {
    return {
      success: false,
      message: "‚ùå Ph√≤ng ƒëang kh√¥ng nh·∫≠n c∆∞·ª£c. Vui l√≤ng ƒë·ª£i v√≤ng m·ªõi b·∫Øt ƒë·∫ßu."
    };
  }
  
  // Get user
  const user = db.users.get(userId);
  if (!user) {
    return {
      success: false,
      message: "‚ùå B·∫°n ch∆∞a ƒëƒÉng k√Ω t√†i kho·∫£n. Vui l√≤ng s·ª≠ d·ª•ng l·ªánh /register ƒë·ªÉ ƒëƒÉng k√Ω."
    };
  }
  
  // Check if user has enough balance
  if (user.balance < betAmount) {
    return {
      success: false,
      message: "‚ùå S·ªë d∆∞ kh√¥ng ƒë·ªß ƒë·ªÉ ƒë·∫∑t c∆∞·ª£c."
    };
  }
  
  // Validate bet amount
  if (betAmount < config.GAMES.TAIXIU_ROOM.MIN_BET || betAmount > config.GAMES.TAIXIU_ROOM.MAX_BET) {
    return {
      success: false,
      message: `‚ùå S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i t·ª´ ${config.GAMES.TAIXIU_ROOM.MIN_BET.toLocaleString()} ƒë·∫øn ${config.GAMES.TAIXIU_ROOM.MAX_BET.toLocaleString()} VNƒê.`
    };
  }
  
  // Deduct bet amount from user's balance
  db.users.updateBalance(userId, -betAmount);
  
  // Add bet to the room
  const bet = {
    userId: userId,
    amount: betAmount,
    timestamp: moment().format('YYYY-MM-DD HH:mm:ss')
  };
  
  // Update room state based on bet type
  switch (betType) {
    case 'tai':
      roomState.bets.tai.push(bet);
      roomState.totalBets.tai += betAmount;
      break;
    case 'xiu':
      roomState.bets.xiu.push(bet);
      roomState.totalBets.xiu += betAmount;
      break;
    case 'chan':
      roomState.bets.chan.push(bet);
      roomState.totalBets.chan += betAmount;
      break;
    case 'le':
      roomState.bets.le.push(bet);
      roomState.totalBets.le += betAmount;
      break;
    default:
      // Should never happen due to validation
      return {
        success: false,
        message: "‚ùå Lo·∫°i c∆∞·ª£c kh√¥ng h·ª£p l·ªá. Vui l√≤ng ch·ªçn tai, xiu, chan ho·∫∑c le."
      };
  }
  
  // Update the room status message
  bot.editMessageText(
    getStatusMessage(roomState),
    {
      chat_id: chatId,
      message_id: roomState.messageId,
      parse_mode: 'Markdown'
    }
  ).catch(err => console.error('Error updating room status:', err));
  
  // Return success message
  return {
    success: true,
    message: `‚úÖ ƒê·∫∑t c∆∞·ª£c th√†nh c√¥ng!\n- C∆∞·ª£c: ${betType === 'tai' ? 'T√†i' : betType === 'xiu' ? 'X·ªâu' : betType === 'chan' ? 'Ch·∫µn' : 'L·∫ª'}\n- S·ªë ti·ªÅn: ${betAmount.toLocaleString()} VNƒê`
  };
}

module.exports = {
  startNewRound,
  placeBet,
  getRoomState // Xu·∫•t h√†m n√†y ra ƒë·ªÉ c√≥ th·ªÉ ki·ªÉm tra tr·∫°ng th√°i ph√≤ng
};